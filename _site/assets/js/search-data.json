{"0": {
    "doc": "Activities and Exercises",
    "title": "Activities",
    "content": "This document will describe how to run certain scripts for artistic effects! . ",
    "url": "http://localhost:4000/activities.html#activities",
    "relUrl": "/activities.html#activities"
  },"1": {
    "doc": "Activities and Exercises",
    "title": "Activity 1: Running Bash and FFmpeg",
    "content": "Before we get started with this section, make sure that your terminal window is in the root level of the ffmpeg-artschool directory. You can do this by typing cd then dragging in the ffmpeg-artschool folder. Also, for these activities we’re going to use ffplay to stream the videos we’re creating, rather than save them. In order to do this we’re using the following format: . ffmpeg -i [InputFile.mov] -c:v prores -filter_complex [Filter String] -f matroska - | ffplay - . The last portion that says -f matroska - | ffplay - is telling ffmpeg to output what it’s processing as a matroska file, and then telling ffplay to play back whatever it coming out of ffmpeg as it comes out. This means that if your computer can’t handle the processing, it might be a bit slow to play back the file. This is why most of our sample files are at 640x480, which is easier for a CPU to handle than a large HD or 2K file. Normalizing your source video_files . All of the video files we provide have been normalized to ProRes. However, if you have your own sample files that you want to use, it’s best to make sure it’s transcoded to ProRes and resized to SD before working with it. We’ve created a simple bash script that can help you with this. Here’s how ton run the script: ./bash_scripts/proreser.sh -s [/path/to/input/file.mov] 640x480 . By default, the proreser.sh script will convert your file to ProRes. By adding the -s flag we’re telling the script to save the output file. By adding 640x480 to the end of the command we’re telling the script to resize the file to 640 pixels by 480 pixels. ",
    "url": "http://localhost:4000/activities.html#activity-1-running-bash-and-ffmpeg",
    "relUrl": "/activities.html#activity-1-running-bash-and-ffmpeg"
  },"2": {
    "doc": "Activities and Exercises",
    "title": "Activity 2: Chromakey and Echo",
    "content": "Chromakey . The Chromakey effect is used to remove any pixel that is a specific color from a video and turn it transparent. Once the color has been turned transparent the video can be overlayed over another video file and the second file will appear “behind” the removed pixels. The bash script chromakey.sh takes care of the chromakey AND the overlay at once. Let’s take it step by step. | Find any file in the video_files directory that has greenscreen_ in the name. We’ll use greenscreen_skulls for the main file. You can use any other video file for the second. We’ll use Cat01.mov for this example | We’ll see what it looks like to overlay two files without Chromakey ffmpeg -i ./video_files/Cat01.mov -i ./video_files/greenscreen_diamond_02.mov -c:v prores -filter_complex '[0:v][1:v]overlay,format=yuv422p10le[v]' -map '[v]' -f matroska - | ffplay - . | Well that wasn’t very fun! All you’ll see is the original greenscreen video. This is just to prove that you can’t overlay files with out the chromakey filter. | Now we’ll see what it looks like to remove the green in the main file with with the following command ffmpeg -i ./video_files/greenscreen_diamond_02.mov -c:v prores -filter_complex 'chromakey=0x00FF00:0.4:0.1' -f matroska - | ffplay - . | You should see that the green has all been removed. The black that’s leftover is a special black. It’s not actually a black pixel, but an absence of any video data at all! Now see what it looks like when we perform the overlay after chromakeying with the following command: ffmpeg -i ./video_files/Cat01.mov -i ./video_files/greenscreen_diamond_02.mov -c:v prores -filter_complex '[1:v]chromakey=0x00FF00:0.4:0.1[1v];[0:v][1v]overlay,format=yuv422p10le[v]' -map '[v]' -f matroska - | ffplay - . | Congrats! You’ve now chromakeyed a file and overlayed over another file! The script chromakey.sh will do this for you automatically, with many extra options. It will also automatically resize the files so that their dimensions match. | . Echo . This echo effect is based off a classic tape echo effect for audio. It adds decaying repetitions to an input file. When using this effect make sure to use an effects with big sweeping motions (like dancers!) for the best results. For this example we’ll use retrodancers.mov . | Run the default echo effects on RetroDancer.mov with the following command ./bash_scripts/echo.sh -p ./video_files/retrodancers.mov . | For the sake of clarity, this is the same as running this command, which shows all the default arguments used (0.2 second echo, Level 2 trails, Blend mode 1) ./bash_scripts/echo.sh -p ./video_files/retrodancers.mov 0.2 2 1 . | Now let’s adjust the time of the echo. We can set it to a much shorter time with more trails for a more washy effect: ./bash_scripts/echo.sh -p ./video_files/retrodancers.mov 0.05 5 1 . | The fun really starts when we try different blend modes. Let’s do the same short delay time with heavy trails, but using the Pheonix blend mode, which is mode 3 ./bash_scripts/echo.sh -p ./video_files/retrodancers.mov 0.05 5 3 . | We can make it even crazier with the XOR blend mode: 5 ./bash_scripts/echo.sh -p ./video_files/retrodancers.mov 0.05 5 7 . | XOR mode is wild! But we can actually make it a bit more interesting by really slowing down the delay time and reducing the trails. Let’s try that ./bash_scripts/echo.sh -p ./video_files/retrodancers.mov 0.5 3 7 . | Now you’ve seen some of what echo can do, try experimenting! | . ",
    "url": "http://localhost:4000/activities.html#activity-2-chromakey-and-echo",
    "relUrl": "/activities.html#activity-2-chromakey-and-echo"
  },"3": {
    "doc": "Activities and Exercises",
    "title": "Activity 3: Bitplane, Blend, Zoom/Scroll",
    "content": "Bitplane . This one is based on the QCTools bitplane visualization, which “binds” the bit position of the Y, U, and V planes of a video file using FFmpeg’s lutyuv filter. This script has randomness built right into it, yielding different, often colorful results, each time you run it. | Let’s start here, with a totally random call: ./bash_scripts/bitplane.sh -p ./video_files/jumpinjackflash.mov . | Let’s test this, by playing Jumpin’ Jack Flash but visualizing ONLY the 2 bitplane of the Y channel: ./bash_scripts/bitplane.sh -p ./video_files/jumpinjackflash.mov 2 -1 -1 . You can see how this plays out, with a black and white, fairly blocky image as a result (remember: in this kind of YUV video, the lower bits are “more significant,” meaning they contain more image data and serve as the foundational building blocks of your digital image). Returning to a random run, you should be able to see in your terminal window another fun aspect of this script: it prints out the Y, U, and V values that were either randomly chosen or hand-selected. *******START FFPLAY COMMANDS******* Y: 5 U: 9 V: 10 . The idea here is that you can run the script over and over (q is a good way to quit FFplay between runs) and when you end up with a video that most suits your artistic temperament, you can easily swap out the -p flag for a -s. | Do this and save your favorite file for our next activity, Zoom/Flip/Scroll./bash_scripts/bitplane.sh -s ./video_files/jumpinjackflash.mov FAVORITE_Y FAVORITE_U FAVORITE_V . | . Zoom/Flip/Scroll . A play on the Line 21 closed caption extraction tool sccyou, zoom/flip/scroller takes a single line of video, zooms in extra close, flips it on its axis, and scrolls up vertically. Designed to visualize and analyze closed captioning information, which lives at the tippy top of the video raster, this re-purposing generates results unlike any other. And, as with bitplane, zoomflipscroller defaults to a randomly selected line (between 1-350) but will also accept a user-specified input. | Let’s start with the original intention for this code, visualizing the closed captions in Jumpin’ Jack Flash. Note: it’s confusing, but “line 21” captions typically live around lines 1 or 2 in a digital video (the “21” refers to an analog space): ./zoomflipscroller.sh -p ./video_files/jumpinjackflash.mov 1 . It’s fun to be able to see captions in this way, and it helps us understand how this digital information gets “read” and transformed into text, but it’s also worth checking out what other lines of video look like this close up. | So let’s try the script one more time, on the same video, but let’s let zoom/flip/scroller randomly choose a line for us: ./zoomflipscroller.sh -p ./video_files/jumpinjackflash.mov . To us, this results in video that has a distinct modern art vibe; it’s all color and lines and weird squiggly shapes. | But what might be even MORE FUN is to try it out on our bitplaned Jumpin’ Jack Flash: ./zoomflipscroller.sh -p ./video_files/jumpinjackflash_bitplane.mov . | . What kinds of results did you get, and did you dig them? . ",
    "url": "http://localhost:4000/activities.html#activity-3-bitplane-blend-zoomscroll",
    "relUrl": "/activities.html#activity-3-bitplane-blend-zoomscroll"
  },"4": {
    "doc": "Activities and Exercises",
    "title": "Activity 4: Tblend, Pseudocolor, Showcqt",
    "content": ". | Find bloodmoon_a.mov and bloodmoon_b.mov in the Sample Videos folder | Use tblend’s difference128 filter and hstack to compare these two similar videos and see if the bad frame/s jump out from behind the gray. ffmpeg -i bloodmoon_a.mov -i bloodmoon_b.mov -filter_complex \"[0:v:0]tblend=all_mode=difference128[a];[1:v:0]tblend=all_mode=difference128[b];[a][b]hstack[out]\" -map [out] -f nut -c:v rawvideo - | ffplay - . | Try out tblend.sh with the same experimental whimsy as the previous activity, playing around with various blend modes. Choose a mode and preview your result with bloodmoon_b.mov in the sample videos folder: ./tblend.sh -p bloodmoon_b.mov xor . | Run again and -s if you like what you see. | Blend your output file back with bloodmoon_b.mov and try the vividlight mode to add another layer of fun, like so: ./blend.sh -s bloodmoon_b_tblend.mov bloodmoon_b.mov vividlight . | Use this new combo file with either pseudocolor.sh or combine it with an audio file to change things up with audioviz.sh!(note: audio will not play back with -p, only with -s) ./audioviz.sh -p jackhammer.mp3 bloodmoon_b_blend.mov . Neato! . | . ",
    "url": "http://localhost:4000/activities.html#activity-4-tblend-pseudocolor-showcqt",
    "relUrl": "/activities.html#activity-4-tblend-pseudocolor-showcqt"
  },"5": {
    "doc": "Activities and Exercises",
    "title": "Activities and Exercises",
    "content": " ",
    "url": "http://localhost:4000/activities.html",
    "relUrl": "/activities.html"
  },"6": {
    "doc": "CLI Tips and Tricks",
    "title": "Command Line Tips and Tricks",
    "content": " ",
    "url": "http://localhost:4000/clitipsandtricks.html#command-line-tips-and-tricks",
    "relUrl": "/clitipsandtricks.html#command-line-tips-and-tricks"
  },"7": {
    "doc": "CLI Tips and Tricks",
    "title": "macOS terminal",
    "content": "To get the most of this workshop, it’s worth briefly reviewing some command line shortcuts that will help you make more art more quickly. | control + A : moves cursor to the beginning of the line | control + E : moves cursor to the end of the line | control + C : kills a running process | command + N : opens a new terminal window | command + T : opens a new terminal tab | command + Delete : erases character to the right of the cursor | Delete : erases character to the left of the cursor | control + U : clears current line | command + K : clears terminal to start | command + L : clears terminal to previous mark | Holding the Option key + moving the pointer : repositions the insertion point (super handy for switching a -p flag to a -s flag) | command + Plus (+) : makes terminal font bigger | command + Minus (-) : makes terminal font smaller | Arrow Up : scrolls through previously entered commands | Arrow Down : goes in the opposite direction | Tab : autocompletes a command after typing a few letters | . ",
    "url": "http://localhost:4000/clitipsandtricks.html#macos-terminal",
    "relUrl": "/clitipsandtricks.html#macos-terminal"
  },"8": {
    "doc": "CLI Tips and Tricks",
    "title": "PowerShell",
    "content": ". | Home : moves cursor to the beginning of the line | End : moves cursor to the end of the line | control + C : kills a running process | alt + X then i : opens a new powershell window | Del : erases character to the right of the cursor | Backspace : erases character to the left of the cursor | Esc : deletes entire current line | control + Home : deletes all characters at the current position up to the beginning of the line | control + End : deletes everything from the current cursor position up to the end of the line | Arrow Up : scrolls through previously entered commands | Arrow Down : goes in the opposite direction | Tab : autocompletes a command after typing a few letters | Tab : autocompletes a command after typing a few letters | . ",
    "url": "http://localhost:4000/clitipsandtricks.html#powershell",
    "relUrl": "/clitipsandtricks.html#powershell"
  },"9": {
    "doc": "CLI Tips and Tricks",
    "title": "CLI Tips and Tricks",
    "content": " ",
    "url": "http://localhost:4000/clitipsandtricks.html",
    "relUrl": "/clitipsandtricks.html"
  },"10": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": ". Please complete the following instructions before the start of the workshop. Total setup time is approximately 15 minutes. ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"11": {
    "doc": "Getting Started",
    "title": "Download the scripts for the workshop",
    "content": ". | Go the Github repository for the workshop | Click the green button labeled Code and choose Download ZIP from the drop-down menu. | Open the folder where the ZIP file was downloaded (probably your Downloads folder) and unzip the file. | Open the unzipped folder, and then open the folder named ffmpeg-artschool-main. You should see folders named bash_scripts and powershell_scripts. | . ",
    "url": "http://localhost:4000/#download-the-scripts-for-the-workshop",
    "relUrl": "/#download-the-scripts-for-the-workshop"
  },"12": {
    "doc": "Getting Started",
    "title": "Download the sample files for the workshop",
    "content": ". | Go the Sample Files for the workshop | Click the name of the folder sample_files and select Download from the drop-down menu. | Open the folder where the ZIP file was downloaded (probably your Downloads folder) in a new window and unzip the file. | Open the unzipped folder, copy the folder named sample_files, and paste it into the ffmpeg-artschool-main folder. | . ",
    "url": "http://localhost:4000/#download-the-sample-files-for-the-workshop",
    "relUrl": "/#download-the-sample-files-for-the-workshop"
  },"13": {
    "doc": "Getting Started",
    "title": "Install or update ffmpeg",
    "content": "These instructions differ depending on what operating system you are using. Mac/Linux . | Open a terminal window by pressing command and space on your keyboard to open Spotlight, typing Terminal, and pressing enter. | Check if you have ffmpeg installed and what version you have installed. In the terminal, type ffmpeg -version and press enter. | If the output says command not found, you will have to install ffmpeg. Continue to step 3. | If the first line of output starts with ffmpeg version 3 or lower, you will have to update your installation of ffmpeg. Continue to step 3 | If the first line of output starts with ffmpeg version 4, you have the version of ffmpeg required for the workshop. Go to Testing Your Setup. | . | We will use homebrew to install or upgrade ffmpeg. To check you have homebrew installed, type brew --version and press enter. | If the output says command not found, you will have to install homebrew. Copy the following command, paste it into your terminal, and run it. While this command runs, you may have to enter your password or respond y several times in order to grant permission for the installation to complete. Then, continue to step 4 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" | Otherwise, continue to step 4. | . | In the terminal, type brew update &amp;&amp; brew upgrade ffmpeg and press enter. | If the output says brew not installed, type brew install ffmpeg and press enter. | . | . Windows . | Open a Powershell window, by opening the Start Menu, typing Powershell, and then clicking Powershell. | Check if you have ffmpeg installed and what version you have installed. In the Powershell window, type ffmpeg.exe -version and press enter. | If the output says command not found, you will have to install ffmpeg. Continue to step 3. | If the first line of output starts with ffmpeg version 3 or lower, you will have to update your installation of ffmpeg. Continue to step 3 | If the first line of output starts with ffmpeg version 4, you have the version of ffmpeg required for the workshop. Go to Testing Your Setup. | . | We will use scoop to install or upgrade ffmpeg and install ported versions of common bash programs (coreutils). To check you have scoop installed, type scoop and press enter. | If the output says command not found, you will have to install scoop. Copy the following command, paste it into your Powershell window, and run it. While this command runs, you may have to enter your password or respond y several times in order to grant permission for the installation to complete. Then, continue to step 4 iwr -useb get.scoop.sh | iex . | If you get an error, you will need to grant permissions to run the installation script. Copy the following command, paste it into your Powershell window, and run it. Set-ExecutionPolicy RemoteSigned -scope CurrentUser | . | Otherwise, continue to step 4. | . | In the Powershell window, type scoop install ffmpeg coreutils and press enter. | If ffmpeg is already installed, type scoop update ffmpeg and press enter. 5. | . | . ",
    "url": "http://localhost:4000/#install-or-update-ffmpeg",
    "relUrl": "/#install-or-update-ffmpeg"
  },"14": {
    "doc": "Getting Started",
    "title": "Test that everything is working",
    "content": "Mac/Linux . | In the terminal, change your working directory to the workshop folder. For example, if you downloaded and unzipped the github repository to your Downloads folder, you would use the following command cd ~/Downloads/ffmpeg-artschool-main/ffmpeg-artschool-main | Test a script ./bash_scripts/life.sh -p . | If you see any errors, please email the workshop organizers. | . | . Windows . | In the terminal, change your working directory to the workshop folder. For example, if you downloaded and unzipped the github repository to your Downloads folder, you would use the following command cd ~\\Downloads\\ffmpeg-artschool-main\\ffmpeg-artschool-main\\ | Test a script .\\powershell_scripts\\life.ps1 -p . | If you see any errors, please email the workshop organizers. | . | . ",
    "url": "http://localhost:4000/#test-that-everything-is-working",
    "relUrl": "/#test-that-everything-is-working"
  },"15": {
    "doc": "Resources",
    "title": "Resources",
    "content": " ",
    "url": "http://localhost:4000/resources.html",
    "relUrl": "/resources.html"
  },"16": {
    "doc": "Resources",
    "title": "Helpful built-in FFmpeg commands",
    "content": ". | man ffmpeg | ffmpeg -version | ffmpeg -pix_fmts | ffmpeg -codecs | ffmpeg -h encoder=codecname . | change ‘encoder’ to ‘decoder’ or ‘muxer’ for more info, ex: . | ffmpeg -h muxer=matroska | . | . | ffmpeg -filters | ffmpeg -h filter=filtername . | ffmpeg -h filter=signalstats | . | . ",
    "url": "http://localhost:4000/resources.html#helpful-built-in-ffmpeg-commands",
    "relUrl": "/resources.html#helpful-built-in-ffmpeg-commands"
  },"17": {
    "doc": "Resources",
    "title": "Other Great Resources",
    "content": ". | ffmprovisr | FFmpeg documentation | Fancy Filtering Examples | oioiiooixii blogpsot | Andrew Weaver’s NDSR Tutorial | Carl Eugen Hoyos, No Time to Wait 2 Livestream (02:24:00) | Kieran Kunya, No Time to Wait 3, “Supporting Niche Formats in Open Source Software and Operating Systems” | . ",
    "url": "http://localhost:4000/resources.html#other-great-resources",
    "relUrl": "/resources.html#other-great-resources"
  },"18": {
    "doc": "Resources",
    "title": "Thanks",
    "content": "Special thanks to Paul Mahol, oioiiooixii, and Dave Rice, whose work not only paved the way but also directly inspired a good part of FFmpeg Art School. ",
    "url": "http://localhost:4000/resources.html#thanks",
    "relUrl": "/resources.html#thanks"
  },"19": {
    "doc": "Schedule",
    "title": "Schedule",
    "content": "| Time | Activity | Notes | . | 11:30AM - 11:45AM EST | Hello + Fun Kick-off | We’ll hit the ground with something colorful (Conway’s Game of Life) | . | 11:45AM - 12:00PM EST | Introduction to FFmpeg | History, Basics, Helpful Hints | . | 12:00PM - 12:15PM EST | Activity 1 | Running Bash and FFmpeg | . | 12:15PM - 12:45PM EST | Understanding Filterchains &amp; Filtergraphs | Truly all you’ll ever need to know about FFmpeg filtering | . | 12:45PM - 1:15PM EST | Break Time | Enjoy a beverage/food, move around a little | . | 1:15PM - 1:30PM EST | Activity 2: Chromakey and Echo | Green screens and laggy effects | . | 1:30PM - 2:00PM EST | FFmpeg for Archives + Preservation | Seems boring but it’s not | . | 2:00PM - 2:15PM EST | Activity 3: Bitplane, Blend, Zoom/Scroll | YUV plane manipulation, derivative file comparison, and twisting a Line 21 viewer | . | 2:15PM - 2:45PM EST | FFmpeg + QC | Video levels and audio spectrograms | . | 2:45PM - 3:00PM EST | Activity 4: Pseudocolor, Showcqt | Repurposing signal analysis tools tools | . | 3:00PM - 4:00PM EST | Open Studio + Show ‘n’ Tell | Go wild! Mix and Match | . ",
    "url": "http://localhost:4000/schedule.html",
    "relUrl": "/schedule.html"
  },"20": {
    "doc": "Scripts",
    "title": "Instructions for FFmpeg Scripts",
    "content": ". | Bash and Powershell | General Usage (and -h for help) | Preview (-p) or Save (-s) | Optional Parameters | audioviz | bitplane | bitplaneslices | blend | chromakey | colorizer | corruptor | echo | gif | jetcolor | lagfun | life | lumakey | procamp | proreser | pseudocolor | rainbow-trail | repeat | reverse | rotate | tblend_glitch | tblend | text | tile | trim | xstack | zoomflipscroller | . ",
    "url": "http://localhost:4000/scripts.html#instructions-for-ffmpeg-scripts",
    "relUrl": "/scripts.html#instructions-for-ffmpeg-scripts"
  },"21": {
    "doc": "Scripts",
    "title": "Bash and Powershell",
    "content": "We have created Bash versions (for Mac and Linux users) and Powershell versions (for Windows users) of all scripts. We tried to make these versions act as similar as possible to one another, but you will notice some differences. For example, Bash scripts end with .sh and Powershell scripts end with .ps1. Ihe presenter is using a Mac and you are using a PC, when they type script.sh, you should type script.ps1. The scripts also print different information as output. If you see different help notes, error messages, or ffmpeg output than the presenter, that’s ok. ",
    "url": "http://localhost:4000/scripts.html#bash-and-powershell",
    "relUrl": "/scripts.html#bash-and-powershell"
  },"22": {
    "doc": "Scripts",
    "title": "General Usage (and -h for help)",
    "content": "Nearly all of the scripts offer users two main paths: previewing the manipulated video with FFplay or saving directly to a file with FFmpeg. Due to the taxing nature of some of these visualizations, your computer may not be able to preview with FFplay in a completely seamless fashion (prepare for the possibility of laggy playback). But fear not: you should be able to at least get a sense of how your art will look, and these delays will not carry over into your resulting files. All scripts also come equipped with built-in help instructions, which can be pulled up with a -h flag. For example, running the following: ./bitplane.sh -h . Will spit out these helpful hints: . Usage bitplane.sh [OPTIONS] INPUT_FILE Y_BITPLANE U_BITPLANE V_BITPLANE Options -h display this help -p previews in FFplay -s saves to file with FFmpeg Notes Outcome Manipulate Y, U, and V bitplanes to make colorful creations dependencies: ffmpeg 4.3 or later . ",
    "url": "http://localhost:4000/scripts.html#general-usage-and--h-for-help",
    "relUrl": "/scripts.html#general-usage-and--h-for-help"
  },"23": {
    "doc": "Scripts",
    "title": "Preview (-p) or Save (-s)",
    "content": "One of the operating assumptions of FFmpeg Art School is that you’ll want to try out a whole range of possibilities before settling on the look of your final artwork. To help you in this process, you can preview by using the -p flag. For example: ./lagfun.sh -p ./video_files/retrodancers.mov . If you’re satisfied with the echoey look of these Retro Dancers, you can re-run the previous command and simply swap the -p for -s to call FFmpeg and tell it to create and save the file. Note: for Powershell script users, the -p flag first encodes the video to a temporary file and then plays the file with ffplay, so you will not see immediate feedback. Note: when “saving” files, the resulting file will be placed in the same directory as the file you’re manipulating, with a helpful filename suffix that should call your attention. In the above case, the resulting file would be called retrodancers_lagfun.mov and it would live in the same video_files directory as the original. For consistency and ease-of-use, all of the FFmpeg Art School scripts currently transcode input files to Prores HQ 422, wrapped in Quicktime (.mov). But feel free to adapt these to your wants or needs! . MOST IMPORTANT: the -p or -s flags are required, so if you run the scripts without them, nothing will happen! . ",
    "url": "http://localhost:4000/scripts.html#preview--p-or-save--s",
    "relUrl": "/scripts.html#preview--p-or-save--s"
  },"24": {
    "doc": "Scripts",
    "title": "Optional Parameters",
    "content": "Many—but not all—of the scripts allow for customization through the use of optional parameters (or positional arguments) passed by the user when executing a script. In almost all cases, we’ve written code that either defaults to pre-set options or makes random selections, but these variables can always be adjusted by the user as needed. And, most importantly, whether options are available for a script or not, they will be described in depth in the help documentation (run the script with a -h flag). To take one example, the bitplane script, which manipulates the Y, U, and V planes of a video to make colorful creations, defaults to randomly chosen numbers between -1 and 10 for all three variables. But, if after running the script a number of times in preview mode, you’re happy with the look of a particular combination, you can re-run the script in the following way to hard set those numbers: ./bitplane.sh -p ./video_files/retrodancers.mov 3 4 1 . ",
    "url": "http://localhost:4000/scripts.html#optional-parameters",
    "relUrl": "/scripts.html#optional-parameters"
  },"25": {
    "doc": "Scripts",
    "title": "audioviz",
    "content": "Creates an audio visualization overlay by blending two input files (one video, one audio) and using FFmpeg’s displace and showcqt filters. Essentially, the audio file gets passed through a frequency spectrum generating filter (showcqt) and the video file is forced to conform to the undulating waves of the audio. Sounds crazy, looks like this (Color Bars + Jumpin’ Jack Flash): . Usage: ./audioviz.sh -p ./audio_files/jumpin.wav ./video_files/colorbars.mov . Input 1: the audio file . Input 2: the video file . ",
    "url": "http://localhost:4000/scripts.html#audioviz",
    "relUrl": "/scripts.html#audioviz"
  },"26": {
    "doc": "Scripts",
    "title": "bitplane",
    "content": "Based on the QCTools bitplane visualization, which “binds” the bit position of the Y, U, and V planes of a video file by using FFmpeg’s lutyuv filter. The script has randomness built into it, and the numerical values—a range between -1 and 10—for the Y, U, and V planes will vary upon successive runs, yielding cool and different results each time you give it a spin. NOTE: -1 will be the equivalent of removing a plane entirely, while 0 is essentially a stand-in for not manipulating a channel at all (so three zeroes will look exactly like the video would without any change at all). In YUV video, there are two things to keep in mind: . | Generally, the most significant bits are the lower value numbers—aka most of the image data lives in these lower bits—and as you go up the ranks to 10, your results will become noisier (harder to discern the source). | In color difference video, Y equates to luma, or brightness, or black and white information; U to R-Y; and V to B-Y, so adjusting Y numbers will make the most dramatic difference, while adjusting U and V will make the most colorful difference. | . Some additional helpful info from the QCTools documentation: . For the Y plane a pixel will display as black if that bit is ‘0’ or white if that bit is ‘1’. For U a pixel will be yellow-green if ‘0’ purple if ‘1’. For V a pixel will be green for ‘0’ and red for ‘1’. Generally lossy video codecs will show blocky structured patterns at higher numbered bit positions. Usage: ./bitplane.sh -p ./video_files/fonda.mov 1 6 -1 . Input 1: the video file . Input 2 (optional, random if unspecified): the Y channel (-1-10) . Input 3 (optional, random if unspecified): the U channel (-1-10) . Input 4 (optional, random if unspecified): the V channel (-1-10) . ",
    "url": "http://localhost:4000/scripts.html#bitplane",
    "relUrl": "/scripts.html#bitplane"
  },"27": {
    "doc": "Scripts",
    "title": "bitplaneslices",
    "content": "Totally lifted from QCTools, this script manipulates ONLY the Y plane of a video file (with FFmpeg’s lutyuv filter) to create a “sliced” effect in which cropped sections of the source video are presented in numerical order from most significant bit (1) to least (10). Hard to describe, looks like this: . Original video . Passed through bitplaneslices . Usage: ./bitplaneslices.sh -p ./video_files/jumpinjackflash.mov . Input 1: the video file . ",
    "url": "http://localhost:4000/scripts.html#bitplaneslices",
    "relUrl": "/scripts.html#bitplaneslices"
  },"28": {
    "doc": "Scripts",
    "title": "blend",
    "content": "Blends two files together in a variety of ways, using FFmpeg’s blend filter. The first input will serve as the “top” layer, the second the “bottom.” Defaults to addition128, but a number of other options are available (don’t miss out on xor!): . addition, addition128, grainmerge, and, average, burn, darken, difference, difference128, grainextract, divide, dodge, freeze, exclusion, extremity, glow, hardlight, hardmix, heat, lighten, linearlight, multiply, multiply128, negation, normal, or, overlay, phoenix, pinlight, reflect, screen, softlight, subtract, vividlight, xor . Usage: ./blend.sh -p ./video_files/brain.mov ./video_files/fonda.mov pinlight . Input 1: the first video file (top layer) . Input 2: the second video file (bottom layer) . Input 3 (optional): the blend mode . MRI brain scan + Jane Fonda’s Workout (pinlight) . MRI brain scan + Jane Fonda’s Workout (xor) . ",
    "url": "http://localhost:4000/scripts.html#blend",
    "relUrl": "/scripts.html#blend"
  },"29": {
    "doc": "Scripts",
    "title": "chromakey",
    "content": "Combines two files using chromakey effects, using FFmpeg’s chromakey filter. Fairly straightforward, but you do have to have at least one file that contains the “green” screen that will be replaced with transparency. Usage: ./chromakey.sh -p ./video_files/green_octopus.mov ./video_files/neonsquigglelines.mov . Input 1: the video file that contains the “green screen” or color to be keyed out . Input 2: the video file that will appear behind the keyed video . Input 3 (optional): the color to be keyed. Any hex color code can be entered, as well as the following colors: green, blue, red, purple, orange, and yellow. The default value is green or 00FF00. Input 4 (optional): the similarity level. Default value is 0.6 The closer to 1 the more will be keyed out. Input 5 (optional): the blending level. Default value is 0.1 . Green Screen Octopus . Background video (neon squiggle lines) . Chromakeyed video . ",
    "url": "http://localhost:4000/scripts.html#chromakey",
    "relUrl": "/scripts.html#chromakey"
  },"30": {
    "doc": "Scripts",
    "title": "colorizer",
    "content": "Re-mixes a video’s color channels using FFmpeg’s colorchannelmixer filter. Usage: ./colorizer.sh -p ./video_files/shania.mov red . Input 1: the video to be colorized . Input 2: the color (red, orange, yellow, green, blue, purple, white or black) . Shania Twain “That Don’t Impress Me Much” music video . Mixed red . Mixed blue . ",
    "url": "http://localhost:4000/scripts.html#colorizer",
    "relUrl": "/scripts.html#colorizer"
  },"31": {
    "doc": "Scripts",
    "title": "corruptor",
    "content": "Uses FFmpeg’s bitstream noise filter to CORRUPT your video in potentially cool looking ways. Mostly used for fuzzing or error concealment/resilience testing, but adapted here to suit our artistic needs. Usage: ./corruptor.sh -p ./video_files/charli.mov . Input 1: the video to be corrupted . Input 2 (optional): the corruption Amount [default: 0.1]. 0 is no error and 1 is all error. Anything above 0.5 will likely not play . Input 3 (optional): keep temporary file (boolean). Default is 0 (false), use 1 to keep the file but it will probably be wonky . Charli XCX &amp; Christine and the Queens “Gone” music video . Corrupted (with default settings) . ",
    "url": "http://localhost:4000/scripts.html#corruptor",
    "relUrl": "/scripts.html#corruptor"
  },"32": {
    "doc": "Scripts",
    "title": "echo",
    "content": "Uses FFmpeg’s blend filter to create a video echo/ghost/trailing effect. Offers eight different blend modes, with varying effects: . # 1: Normal mode, nice and balanced with evenly blending trails, but gets out of hand with a higher tail length. # 2: Screen mode, Works well with high contrast stuff but gets out of hand very quickly # 3: Phoenix mode, cool psychedelic effect # 4: Softlight mode, trails dissipate very quickly, a subtle effect. # 5: Average mode, Similar to normal with slightly different colors. # 6: Heat mode, image is harshly affects. # 7: Xor mode, very cool strobing effect # 8: Difference mode, slightly less intense than xor but similar . Usage: ./echo.sh -p ./video_files/jellyfish.mov .2 5 3 . Input 1: the video file to be echoed . Input 2 (optional): the echo rate, in seconds (default is 0.2) . Input 3 (optional): the length of trails. 1 is just one trails, number increases exponentially as it goes. Input 4 (optional): the echo mode (choose 1 thru 8) . Jellyfish . Echo Jellies . ",
    "url": "http://localhost:4000/scripts.html#echo",
    "relUrl": "/scripts.html#echo"
  },"33": {
    "doc": "Scripts",
    "title": "gif",
    "content": "Turns a video file into a gif, using FFmpeg’s palettegen filter (good for sharing your art!). Note: this script has no preview mode, it just makes gifs. Usage: ./gif.sh ./video_files/jellyfish_echo.mov 1 . Input 1: the video file . Input 2: the quality of the resulting gif (0 = more compressed, smaller file; 1 = less compressed bigger file) . ",
    "url": "http://localhost:4000/scripts.html#gif",
    "relUrl": "/scripts.html#gif"
  },"34": {
    "doc": "Scripts",
    "title": "jetcolor",
    "content": "Uses FFmpeg’s pseudocolor filter to create a “jetcolor” effect (also boosts the brightness and saturation of the video before the jet takes off). Usage: ./jetcolor.sh -p ./video_files/dancers.mov . Input 1: the video to be jetcolored . Input 2 (optional): toggle between three different jetcolor modes (1-3, default 1) . Original video of dancer . Jetcolor Dancers, mode 1 . Jetcolor Dancers, mode 3 . ",
    "url": "http://localhost:4000/scripts.html#jetcolor",
    "relUrl": "/scripts.html#jetcolor"
  },"35": {
    "doc": "Scripts",
    "title": "lagfun",
    "content": "Creates a different kind of echo/ghost/trailing effect, using FFmpeg’s lagfun filter. Usage: ./lagfun -p ./video_files/jellyfish.mov 3 . Input 1: the video file to be lagged . Input 2: the trail mode (pick 1 thru 3). Try different modes for fun! . Input 3: the trail amount, or intensity of the effect. Default is 1. Lagfun Jellies, trail mode 3 . ",
    "url": "http://localhost:4000/scripts.html#lagfun",
    "relUrl": "/scripts.html#lagfun"
  },"36": {
    "doc": "Scripts",
    "title": "life",
    "content": "One of the only Art School scripts to not require an input file, this one uses FFmpeg’s life filter to generate a visualization based upon John Conway’s Game of Life. Ideal for testing your FFmpeg installation and the starting point of FFmpeg Art School’s lesson plan. Note: if running this script in save mode, the resulting file will be located in your current working directory (in all likelihood bash_scripts or powershell_scripts) . Usage: ./life.sh -p . Input 1 (optional): the game size (small, medium, or large). Default is medium. Input 2 (optional): the color of life (blue, green, red, purple, or orange). Default is yellow. Input 3 (optional): the color of death (blue, green, red, purple, or orange). Default is red. Input 4 (optional): the rate (slow, medium, or fast). Default is random selection. Input 5 (optional): the ratio (low, medium, or high). Default is random selection. Game of Life, also best seen in gif form . ",
    "url": "http://localhost:4000/scripts.html#life",
    "relUrl": "/scripts.html#life"
  },"37": {
    "doc": "Scripts",
    "title": "lumakey",
    "content": "Combines two files using FFmpeg’s lumakey filter, transforming certain luma values into transparency. Usage: ./lumakey.sh ./video_files/green_trex.mov ./video_files/flowers.mov . Input 1: the video that will be keyed . Input 2: the background video . Input 3 (optional): the threshold (0 will key out black, 1 will key out white). Default is 0. Input 4 (optional): the tolerance (if the threshold is 0, use a low number like 0.1 to key out darks. If threshold is 1, use a high number like 0.7 to key out whites). Default is 0.1. Input 5: the softness (softens the key; 0 has sharp edges, 1 is Downy soft, though it’s not advisable to go above 0.4). Default is 0.2. Green screen T-Rex, lumakeyed over timelape video of Nasturtium flowers . ",
    "url": "http://localhost:4000/scripts.html#lumakey",
    "relUrl": "/scripts.html#lumakey"
  },"38": {
    "doc": "Scripts",
    "title": "procamp",
    "content": "A script that mimics a timebase corrector’s (TBC) processing amplification (procamp) controls, allowing for manipulation of the luma, black, chroma, or hue/phase of an input video. Modeled specifically on the DPS-290 TBC, each value has a range of -128 to 128, with 0 being the unchanged amount. Uses FFmpeg’s lutyuv and hue filters to make its manipulations. Usage: ./procamp.sh -p ./video_files/neonlines.mov 0 0 0 65 . Input 1: the video to be procamped . Input 2: adjusts the luma/contrast (-128 to 128, 0 = no change) . Input 3: adjusts the black/brightness (-128 to 128, 0 = no change) . Input 4: adjusts the chroma/saturation, or intensity of color (-128 to 128, 0 = no change) . Input 5: adjusts the hue/phase, or shade of color (-128 to 128, 0 = no change) . Neon Lines . Neon Lines w/ hue adjustment of 65 . ",
    "url": "http://localhost:4000/scripts.html#procamp",
    "relUrl": "/scripts.html#procamp"
  },"39": {
    "doc": "Scripts",
    "title": "proreser",
    "content": "Conforms any input file into a prores file, with an option to resize. Not terribly exciting, but good for normalizing your files before making art. Usage: ./proreser.sh -s ./video_files/neonlines.mov 640x480 . Input 1: the video file to be transcoded to prores/mov . Input 2 (optional): the resolution of the output file, formatted as WxH (ex: 640x480) . ",
    "url": "http://localhost:4000/scripts.html#proreser",
    "relUrl": "/scripts.html#proreser"
  },"40": {
    "doc": "Scripts",
    "title": "pseudocolor",
    "content": "Boosts the video levels on an input file and adds a gradient effect to pixels that are out of broadcast range, using FFmpeg’s pseudocolor filter. Usage: ./pseudocolor.sh -p ./video_files/nightturkey.mov . Input 1: the video file to be boosted and given gradient out-of-range colors . Night Turkey (BAVC EIAJ Test Tape from 1973) . Pseudocolored . ",
    "url": "http://localhost:4000/scripts.html#pseudocolor",
    "relUrl": "/scripts.html#pseudocolor"
  },"41": {
    "doc": "Scripts",
    "title": "rainbow-trail",
    "content": "Adapted from oioiiooixiii and the amazing work described in this blog post, this script generates a rainbow trail effect that’s loosely based on the Scanimate video synthesizer system. A real doozy, uses FFmpeg’s colorkey, chromakey, and colorchannelmixer filters. Usage: ./rainbow-trail.sh -p ./video_files/jellyfish.mov . Input 1: the video to be rainbow trailed . Input 2 (optional): the colorkey value (default: 0000FF) . Input 3 (optional): the similarity value (default 0.3) . Input 4 (optional) the colorkey blend value (default 0.1) . Input 5 (optional): the number of color iterations (default: 7) . Input 6 (optional): alpha plane extraction (default: true) . Rainbow Jellies . ",
    "url": "http://localhost:4000/scripts.html#rainbow-trail",
    "relUrl": "/scripts.html#rainbow-trail"
  },"42": {
    "doc": "Scripts",
    "title": "repeat",
    "content": "Repeats the input file an arbitrary number of times. Makes a temporary concatenation list, uses FFmpeg’s concatenation demuxer to loop it up. NOTE: for this script, preview mode is disabled. Usage: ./repeat.sh -p ./video_files/iknow.mov . Input 1: the video file to be repeated . Input 2 (optional): the number of times to repeat the file. Default 2. I Know What You Did Last Summer, the “What are you waiting for” moment (looping gif, but also a looping video! Believe it!) . ",
    "url": "http://localhost:4000/scripts.html#repeat",
    "relUrl": "/scripts.html#repeat"
  },"43": {
    "doc": "Scripts",
    "title": "reverse",
    "content": "Reverses the input file using FFmpeg’s reverse filter. Usage: ./reverse.sh -p ./video_files/dancers.mov . Input 1: the video file to be reversed . Original video . Reversed . ",
    "url": "http://localhost:4000/scripts.html#reverse",
    "relUrl": "/scripts.html#reverse"
  },"44": {
    "doc": "Scripts",
    "title": "rotate",
    "content": "Rotates an input file with options to resize the output, using FFmpeg’s transpose filter. Usage: ./rotate.sh -p ./video_files/cat.mov 270 1 . Input 1: the video file to be rotated . Input 2: the rotation amount, in degrees (must be 90, 180, or 270) . Input 3: the stretch, to conform an output file to the input’s aspect ratio (1 for true 0 for false) . Cat + Pumpkin . Rotated Cat + Pumpkin (270 degrees, aspect ratio manipulated) . ",
    "url": "http://localhost:4000/scripts.html#rotate",
    "relUrl": "/scripts.html#rotate"
  },"45": {
    "doc": "Scripts",
    "title": "tblend_glitch",
    "content": "Performs a glitchy tblend on an input video file, again adapted from oioiiooixiii . Usage: ./tblend_glitch.sh ./video_files/neonlines.mov 4 . Input 1: the video file to be tblend glitched . Input 2: the blend mode (choose a number between 1 and 4) . Neon lines, tblend glitched 1 . ",
    "url": "http://localhost:4000/scripts.html#tblend_glitch",
    "relUrl": "/scripts.html#tblend_glitch"
  },"46": {
    "doc": "Scripts",
    "title": "tblend",
    "content": "Applies FFmpeg’s tblend filter with an arbitrary blend mode. Trippy trippy stuff. Usage: ./tblend.sh -p ./video_files/flowers.mov xor . Input 1: the video file to be tblended . Input 2: the blend mode. Options include: . addition, addition128, grainmerge, and, average, burn, darken, difference, difference128, grainextract, divide, dodge, freeze, exclusion, extremity, glow, hardlight, hardmix, heat, lighten, linearlight, multiply, multiply128, negation, normal, or, overlay, phoenix, pinlight, reflect, screen, softlight, subtract, vividlight, xor . Nasturtium flowers timelape video, tblend xor . ",
    "url": "http://localhost:4000/scripts.html#tblend",
    "relUrl": "/scripts.html#tblend"
  },"47": {
    "doc": "Scripts",
    "title": "text",
    "content": "Generates text on screen based upon user input, offering a variety of text colors, background colors, sizes, and scroll directions/speeds. Uses FFmpeg’s Libavfilter virtual input device and the drawtext filter to do its thing. Note: this script does not draw text on top of a input file, but rather generates something akin to a title card. So no input file needed! . Usage: ./text.sh -p \"Hello World\" white green 100 up . Input 1: the text to be written. Accepts either text in quotation marks or path to a text file. If text, no apostrophes. If text file. make sure it’s plain text. Input 2: the color of the text (white, black, silver, grey, green, blue, yellow, red, purple, orange). Default: white . Input 3: the background color (white, black, silver, grey, green, blue, yellow, red, purple, orange). Default: black . Input 4: the text size (higher = bigger) . Input 5: the direction of the scroll (left, right, up, down, center). Default: center (no motion) . Input 6: the speed of the scroll (higher = faster) . “Hello World” white text (size 100) on green background, scrolling up . ",
    "url": "http://localhost:4000/scripts.html#text",
    "relUrl": "/scripts.html#text"
  },"48": {
    "doc": "Scripts",
    "title": "tile",
    "content": "Adapted from the QCTools filmstrip filter. Uses the FFmpeg tile filter to create a mosaic, “tiled” effect for the input video, based upon a user selected set of rows and columns. Usage: ./tile.sh -p ./video_files/skull.mov . Input 1: the video file to be tiled . Input 2 (optional): the number of columns (must be a multiple of 2). Default: 4 . Input 3 (optional): the number of rows (must be a multiple of 2). Default: 4 . Input 4 (optional): the output frame size. This will squeeze the output into a specific size. Must be in format “WIDTHxHEIGHT” to work . Green screen black skull . Tiled skulls . ",
    "url": "http://localhost:4000/scripts.html#tile",
    "relUrl": "/scripts.html#tile"
  },"49": {
    "doc": "Scripts",
    "title": "trim",
    "content": "Trims a video file based upon user-defined starting and ending timestamps (HH:MM:SS). Uses FFmpeg’s output seeking to make its cuts. NOTE: for this script, preview mode is disabled. Usage: ./trim.sh -s ./video_files/skull.mov 00:00:00 00:00:10 . Input 1: the video to be trimmed . Input 2: the start point (HH:MM:SS) . Input 2: the end point (HH:MM:SS) . ",
    "url": "http://localhost:4000/scripts.html#trim",
    "relUrl": "/scripts.html#trim"
  },"50": {
    "doc": "Scripts",
    "title": "xstack",
    "content": "Creates a mosaic of multiple input video files using FFmpeg’s xstack filter. Note: though the xstack filter itself is endlessly customizable, this script will only accept a set number of input files that can be stacked into a square shape (4, 9, 16, or 25). Usage: ./xstack.sh -p INPUT_FILE_1 INPUT_FILE_2 INPUT_FILE_3 INPUT_FILE_4 . Input 1: the video file to be situated in the upper left corner . The following inputs will vary based upon the total number to be stacked (4, 9, 16, or 25), but inputs should be sequenced from left to right, from row to row, as desired. 25 colorized videos of Jane Fonda’s workout, arranged in American flag design (riff on Nam June Paik’s “Video Flag”) . ",
    "url": "http://localhost:4000/scripts.html#xstack",
    "relUrl": "/scripts.html#xstack"
  },"51": {
    "doc": "Scripts",
    "title": "zoomflipscroller",
    "content": "A play on one of the visualizations provided by the Line 21 closed caption extraction tool sccyou, zoom/flip/scroller takes a single line of video, zooms in extra close, flips it on its axis, and scrolls up vertically. Designed to visualize and analyze closed captioning information, which lives at the tippy top of the video raster, this re-purposing—which draws upon FFmpeg’s crop, scale, and tile filters—generates results unlike any other. And, as with bitplane, zoomflipscroller defaults to a randomly selected line (between 1-350) but will also accept a user-specified input. Usage: ./zoomflipscroller.sh -p ./video_files/jumpinjackflash.mov 1 . Input 1: the video file to be zoomed/flipped/scrolled . Input 2 (optional): the line to be zeroed in on. Default: random number between 1-350. If your video has line 21 and you’d like to zoom in on it, select 1. Jumpin’ Jack Flash, zoom in on line 21 (line 1) . More fun: random zoom on colorful and random bitplaned video . Bitplaned dancer (Y:3, U:-1, V: 7) . Zoom/Flip/Scroll, line 286 . ",
    "url": "http://localhost:4000/scripts.html#zoomflipscroller",
    "relUrl": "/scripts.html#zoomflipscroller"
  },"52": {
    "doc": "Scripts",
    "title": "Scripts",
    "content": " ",
    "url": "http://localhost:4000/scripts.html",
    "relUrl": "/scripts.html"
  }
}
